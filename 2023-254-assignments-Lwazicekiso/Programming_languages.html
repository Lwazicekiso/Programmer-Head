<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programming languages</title>
    <link rel="stylesheet" href="page_styling.css">
    <link rel="stylesheet" href="Styling_for_pages.css">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    
</head>

    <body>

        <nav id="navigation" >
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="Programming_languages.html">Programming </a></li>
                <li><a href="careers_paths.html">Career Paths</a></li>
                <li> <a href="Roadmaps.html">Roadmap</a></li>
                <li> <a href="Learning_resources.html">Learning Resources</a></li>
            </ul>
        </nav>
        <aside>
            <ol>
                <a href="#Procedural_Programming"><li>Procedural Programming</li></a>
                <a href="#OOP"><li>Object Oriented Programming(OOP)</li></a>
                <a href = "#Functional_Programming"><li>Functional Programming</li></a>
                <a href="#Scripitng_Languages"><li>Scripitng langauges</li></a>
                <a href="#Logical_Programming_Languages"><li>Logicals programming Languages</li></a>
            </ol>
        </aside>
        
        <div class='container'>
            <header id = "top">
     
                <h1>What is Programming</h1>
                <img src="images/images_for_programming_lang/background_2.jpg" alt ="image  of laptop wiwth some code on it" width="500px">
                <p>The term programming refers to communicating with a computer in order to achieve our desired goal.
                    This could range from analyzing data to creating websites. In today digital world programming is a very
                    important skill because it can be used in any field to make tasks easier, more efficient, and accurate. But
                    how do we partake in this communication do we simply use natural language and speak to computers
                    the way we would with our friends? No, there are multiple far too many factors which make this difficult
                    such as natural language being way too ambiguous and sometimes needing common sense. This is
                    where programming languages come in. Programming languages are tools we use to communicate with </p> 
                </p>
                <h1>Types Of Programming Languages</h1>
              
                <p>Although there are various ways to classify programming languages classifying them according to paradigms, such as Procedural, Object-Oriented, Functional, Scripting, and Logical, is essential for clarity, comprehension, and problem-domain alignment. This classification promotes best practices, modular code, and simplifies collaboration between languages, fostering specialization among developers and encouraging innovation and evolution in programming.
                </p>
              
                
                </header>
                
             
                
                <main>
                    <section id="Procedural_Programming">
                        <h2>Procedural Programming</h2>
                            <img src="images/images_for_programming_lang/Procedural_programming.png" alt="image displaying an example of procedural code">
                            <p>
                                let's talk about Procedural Programming! Imagine you're in the kitchen, about to bake a delicious cake. Procedural Programming is a lot like following a recipe to bake that cake. It's all about giving clear, step-by-step instructions to a computer to complete a task.
                                
                                In Procedural Programming, we take a linear approach, just like following a recipe from start to finish. We treat the data, like the ingredients, and the instructions, like mixing or baking, as separate things.
                                
                                Instead of having one big set of instructions, we break them down into smaller sets called procedures. These procedures are like mini-tasks, each with their own series of steps. It's kind of like crafting a sandwich – each step, like "take two slices of bread" or "spread peanut butter on one slice," is like a procedure.
                                
                                But that's not all! In Procedural Programming, there are a few key concepts to explore:
                            </p>
                        
                                <ol>
                                    <li>Predefined Functions: These are like specialized instructions that already have names, such as 'cut,' 'mix,' or 'spread.' They are built into the programming language and help us perform common tasks without having to write out all the details each time.
                                    </li> 
                                    <li>Local Variables: Think of these as containers that hold information, but they can only be used within a specific part of the instructions. It's like having a bowl that you can only use in one step of the recipe.
                                    </li> 
                                    <li>Global Variables: These are like bowls or utensils that you can use anywhere in the recipe. They are available for use in all the steps.
                                    </li> 
                                    <li>Modularity: This is a way of organizing our instructions. It's like having different groups of tasks that can be completed one after the other to achieve a bigger goal, just like preparing all the sandwich ingredients before assembling it.
                                    </li> 
                                    <li>Parameter Passing: This is how we can give additional information to our procedures. For example, if you have a step that says "spread jelly," you might need to specify what type of jelly to spread. Parameter passing allows us to do that.
                                    </li>
                                </ol>
                                <div class="pro_vs_cons">
                                        <h3>Advantages of Procedural Programming:</h3>
                                        <ol>
                                            <li>General-Purpose: Procedural Programming is versatile and can be used for a wide range of tasks.
                                            </li>
                                            <li>Simplicity: It's relatively easy to write and understand code in this style, and it works well with compilers and interpreters (tools that convert code into instructions a computer can follow).
                                            </li>
                                            <li>Learning Resources: There are plenty of books and online courses available that teach proven techniques and algorithms, which makes it easier for beginners to learn.
                                            </li>
                                            <li>Portability: Code written in this style can be used on different types of computers, which is handy if you want your program to work on various machines.
                                            </li>
                                        </ol>
                                    
                                    5. Code Reusability: You can reuse sections of code in different parts of your program without having to duplicate it, saving time and making your code more organized.
                                <h3>Disdvantages of Procedural Programming:</h3>
                                    
                                    <ol> 
                                        <li>Complexity: As programs get larger and more intricate, writing code in this style can become quite complex.
                                        </li>
                                        <li>Limited reusability: When you write code using a procedural approach, it may not be easy to reuse it in different programs, which means you might need to rewrite the code for other uses.
                                        </li>
                                        <li>Abstract concepts: It can be hard to link procedural code with real-world objects or ideas, making some tasks more complicated.
                                        </li>
                                        <li>Data handling: Procedural programming often puts more emphasis on operations (what the program does) rather than data (the information the program works with). This could cause issues when dealing with sensitive or secure data.
                                        </li>
                                        <li>Data exposure: In this coding style, data is available to the entire program, possibly posing security risks in more complex programs.
                                        </li>
                                    </ol>
                                <h4>Examples</h4>
                                <ul>
                                    <li>C</li>
                                    <li>Pascal</li>
                                    <li>COBOL</li>
                                </ul>
                            </div>
                                
                    </section>
                    
                   <section>
                    <H2 id="OOP">Object Oriented Programming</H2>
                            <img src="images/images_for_programming_lang/object-oriented-programming.png" alt="Image displaying some principles  of Objec object-oriented-programming">
                            <p>
                                Now, let's shift gears to the captivating world of <abbr title="Object Oriented Programming" >OOP</abbr>! Brace yourselves for a programming paradigm that's nothing short of revolutionary.
                
                                In OOP, we're not just writing code; we're creating virtual entities called "objects" that have their own unique characteristics and superpowers. These objects take center stage, and it's all about what they can do, rather than how we make them do it.
                                
                                This approach is like a secret weapon for tackling massive, intricate software projects. From crafting manufacturing system simulations to developing cutting-edge mobile apps, OOP's got you covered.
                                
                                But wait, there's more! OOP isn't just about coding; it's a team player. It's fantastic for collaborative development, allowing teams to break down projects into manageable pieces. Plus, it comes with superpowers like code reusability, scalability, and turbocharging efficiency.
                                
                                The adventure begins by identifying all the incredible objects we'll work with and uncovering how they relate to each other – this part is called "data modeling." Objects can be as diverse as real-world people (with names and addresses) or even little software wonders like widgets.
                                
                                Once we've discovered our objects, each one gets a "class" badge, which tells us what kind of data it holds and the cool tricks it can perform (methods). These objects chat with each other using we
                            </p>
                
                        <h3>Main Principles of OOP:</h3>
                            <ol> 
                                <li>Encapsulation: Imagine objects as secretive vaults! In <abbr title="Object Oriented Programming" >OOP</abbr>, we keep all the essential stuff inside objects and only reveal what's needed. Each object's inner workings remain private in a class, safeguarding them from prying eyes. Others can only access a handpicked list of functions, ensuring data security.</li>
                            
                                <li>Abstraction: Abstraction is like an <abbr title="Object Oriented Programming" >OOP</abbr> magic trick! Objects disclose just enough for others to use, concealing the underlying complexity. This approach makes it simpler for developers to modify or introduce new features later on, akin to adding layers to your favorite sandwich.</li>            
                                <li>Inheritance: Picture inheritance as hand-me-downs for classes! It lets classes borrow code from others. Objects can form connections and subclasses, inheriting logic while preserving their distinct identity. It's like building upon existing knowledge, saving time and guaranteeing accuracy.</li>
                            
                                <li>Polymorphism: Visualize objects as shape-shifting actors! They can assume various roles and behaviors, courtesy of polymorphism. It allows a single object to adjust to diverse situations, diminishing the need for repetitive code. It's like a superhero with distinct costumes for various missions!</li>   
                            </ol>
                        <div class="pro_vs_cons">
                            <h3>Advantages of OOP</h3>
                            <ol>
                                <li>Reusability: No more reinventing the wheel! OOP enables code reuse via inheritance, conserving time and effort.</li>
                            
                                <li> Productivity: OOP serves as your productivity catalyst. With libraries and reusable code, programmers can create new programs rapidly.</li>
                                <li>Upgradability and Scalability: OOP empowers developers to independently enhance system functionalities, making upgrades effortlessly manageable.</li>
                                <li>Interface Descriptions: OOP streamlines external system descriptions using smart message-passing strategies for object communication.</li>
                                <li>Security: Encapsulation and abstraction offer a protective layer for complex code, easing software maintenance and shielding internet protocols.</li>
                                <li>Flexibility: Polymorphism permits functions to adapt to various classes, and objects can share the same interface.</li> 
                
                            </ol>
                            
                            <h3>Disadvantages of OOP:</h3>
                                <ol>
                                    <li>Complexity Overload: OOP can sometimes feel like an intricate web of objects, classes, and connections. For smaller projects, this complexity might appear excessive, making you long for the simplicity of alternate programming paradigms.</li>
                                
                                    <li>The Need for Speed: OOP can introduce a bit of a speed bump in terms of performance. All those layers of abstraction and dynamic method calls can slow things down a tad compared to more straightforward approaches.</li>
                                
                                    <li>Memory Hog: Each object you create in OOP carries a little extra baggage in terms of memory. If you're working in resource-constrained environments, this can be a real headache.</li>
                                
                                    <li></li>Verbosity Overload: OOP code can sometimes be a bit wordy. You might need to write more lines of code to do the same thing as you would in other paradigms. It's like writing a novel when a short story would do.
                                
                                    <li>Not Always the One: Let's face it; OOP isn't the hero for every mission. In certain domains like embedded systems or real-time applications, it might be better to suit up with a different programming style.
                                        OOP can be a challenging endeavor, particularly for novices. You'll need to invest considerable effort into understanding concepts like inheritance, polymorphism, and encapsulation. But hey, once you've conquered them, you'll feel like a code-wielding superhero!</li>
                                </ol>
                                <h4>Examples</h4>
                                <ul>
                                    <li>Python</li>
                                    <li>Java</li>
                                    <li>C#</li>
                                </ul>
                        </div>
                   </section>
                        <section id="Functional_Programming">
                            <h2>Functional Programming</h2>
                            <img src="images/images_for_programming_lang/Functional_programming.png" alt="image displaying functional code">
                            <p>Let's dive into the exciting world of functional programming languages! Imagine you have a magic wand that can transform things. Functional programming languages are like magic spells for computers!
                                Instead of giving the computer a series of step-by-step instructions like in other types of programming, in functional programming, we give it special functions to work with. 
                                These functions are like little helpers that can take something in, do some magic with it, and give us something back. No messy steps, just pure magic!
                            </p>
                            <h3>Main Principles:</h3>
                            <ol>
                                <li>Function Superheroes: In functional programming, functions are like the superheroes of code. They can do incredible things, and you can even create your own functions to make the computer follow your every command.</li>
                                <li>No Sneaky Surprises: Functional programming is all about keeping things clean and safe. No hidden surprises that mess up your code, just like having a reliable robot friend who does exactly what you say, no tricks!</li>
                                <li>Treasure Your Data: In this coding world, data is like treasure. You guard it and don't change it. Instead, you craft new data from the old, just like mixing magical ingredients to create new potions!</li>
                                <li>Recursion: Time-Travel Magic: Ever wanted to go back in time to help your past self? Well, in functional programming, you can do something similar with recursion. Functions call themselves to solve problems, like a time-travel adventure!</li>
                                <li>Immutable Magic: Once you create something, it stays as it is. No changes allowed! You create copies with tweaks, just like having a never-ending magical notebook where you add new pages instead of erasing.</li>
                                <li>Immutable Magic: Once you create something, it stays as it is. No changes allowed! You create copies with tweaks, just like having a never-ending magical notebook where you add new pages instead of erasing.</li>
                            </ol>
                            <div class="pro_vs_cons">
                                <h3>Advantages:</h3>
                                <ol>
                                <li>Code Superpowers: Functional programming is like sprinkling magic dust on your code. It keeps everything tidy, elegant, and crystal clear. Say goodbye to messy, mind-boggling chaos!</li>
                                <li>Bug-Proofing Brilliance: Think of it as your trusty bug-buster superhero. With functions that don't play tricks and absolutely no surprise villains, you code with unwavering confidence.</li>
                                <li>Reuse Like a Pro: Functional programming is the ultimate recycling champion. You craft nifty, little code pieces that you can use over and over, saving you time and making your code a lean, mean efficiency machine</li>.
                                <li>Parallel Universe: Ever wanted to be in multiple places at once? Functional code is your multi-tasking wizardry. It can handle several tasks simultaneously, giving your program a turbo boost on today's multi-core computers.</li>
                                <li>Time Travel with Recursion: Recursion is like your secret time-travel hack. It conquers complex problems by slicing them into bite-sized chunks and summoning functions within functions. It's seriously mind-blowing!</li>
                                <li>Data Treasures: Data becomes your hidden treasure chest. You never change it; you craft duplicates with tweaks. This keeps your code as predictable and secure as a fortress.</li>
                                </ol>
                                
                            <h3>Disadvantages:</h3>
                                <ol>
                                    <li>Steep Learning Cliff: Learning functional programming is like scaling a challenging mountain. It's akin to mastering a new language or unlocking a whole new level of magical spells.</li>
                                    <li>Community Quest: The functional programmer clan, while growing, isn't as enormous as some other groups. So, finding help or resources might feel like a thrilling treasure hunt at times.</li>
                                    <li>Performance Gambles: Sometimes, functional code may play a bit slower than code written in other styles. But no worries! Modern compilers are like wizards that make it faster.</li>
                                    <li>Brainpower Required: Functional code can be like tackling complex puzzles. It's a bit abstract, so you'll need to engage your brainpower to unravel its mysteries. </li>
                                </ol>           
                            </div>
                
                            <h4>Examples<h4>
                                <ul>
                                    <li>Haskell</li>
                                    <li>Scala</li>
                                    <li>Clojure</li>
                                </ul>
                            </section>
                    <section  id="Scripitng_Languages">
                        <h2>Scripting Languages</h2> 
                        <img src="images/images_for_programming_lang/Scirpting.png" alt="image of computer written SCRIPTING">
                         <p>Scripting languages! These are like your trusty sidekicks for getting things done quickly and easily, especially when you want to automate tasks. Buckle up, because we're going on an adventure.</p> 
             
                         <h3>Main Principles:</h3>
                         <ol>
                             <li>Interpreted: Think of scripting languages as storytellers. They read the story one line at a time, making it easy for you to follow along.</li>
                             <li>High-Level: They speak plain and simple language, like your best buddy. No need for fancy jargon here!</li>
                             <li>Dynamic Typing: These languages are shape-shifters. Variables can change their forms while the program is running, which can be pretty cool, but watch out for surprises.</li>
                             <li>Easy Syntax: They use short and sweet sentences, just like your favorite bedtime story. Anyone can understand them.</li>
                             <li>Lots of Helpers: It's like having a magical toolbox full of handy tools. They come with lots of ready-made stuff to help you out.</li>
                         </ol>
                         <div class="pro_vs_cons">
                             <h3>Advantages</h3>
                             <ol>
                                 <li>Fast and Easy: Scripting languages are like turbocharged go-karts. You can zoom through tasks quickly without waiting for a long setup.</li>
                                 <li>Works Everywhere: They're like language translators for computers, so they can run on any computer, no matter where you are.</li>
                                 <li>Automation Magic: Want to make your computer do chores for you? These languages are your go-to wizards for automation.</li>
                                 <li>Easy to Read: They tell stories in simple words, just like your favorite adventure book. It's a breeze for anyone to read and understand.</li>
                                 <li>Lots of Friends: These languages have big fan clubs! Many people use them, so you'll always find friends to help you out.</li>
                             </ol>
                         <h3>Disdvantages</h3>
                             <ol>
                                 <li>Not Super Fast: While they're speedy, they might not win the Olympic sprint. They need a bit of translation time to talk to the computer, so they're not the best for super-fast or gigantic tasks.</li>
                                 <li>Sometimes Not Very Safe: Because they're so flexible, you need to keep an eye out for surprises. Sometimes they can let unexpected things happen.</li>
                                 <li>Not for Giant Projects: While they're awesome for everyday tasks, they might struggle with enormous projects. </li>
                                 <li>Not Total Control: They can't control every little detail of the computer. They're more like remote controls for your TV, not the TV itself.</li>
                                 <li>Surprises Sometimes: Brace yourself for the occasional surprise! Since they can change on the fly, they might throw you a curveball now and then.</li>
                             </ol>
                             
                         </div>
                         <h4>Examples</h4>
                         <ul>
                             <li>Ruby</li>
                             <li>JavaScript</li>
                             <li>Pearl</li>
                         </ul>
                    </section>
                    
                    

            
                   
                    <section id="Logical_Programming_Languages">
                        <h2>Logical Programming Languages: Unveiling the Logic of Code!</h2>
                        <img src="images/images_for_programming_lang/logic_based.png" alt="image showing logic based code">
                        <p>Imagine a world where you don't have to tell the computer exactly what to do at every step. Instead, you describe the relationships, rules, and knowledge, and the computer figures it all out!</p>
                            <h3>Principles of Logical Programming Languages:</h3> 
                            <ol>
                                <li>Pattern Matching Mastery: Logical languages excel at pattern matching. You specify a pattern, and the computer hunts down matching solutions.</li>
                                <li>Declarative Style - Say What You Want: In logical languages, you simply declare what you want to happen, and the computer takes care of the rest.</li>
                                <li>Logic-Based Brilliance: Logic is the key. You define facts and rules using logic, letting you express intricate relationships and constraints with ease.</li>
                                <li>Backtracking Brilliance: If a solution doesn't work out, no problem! Logical languages are fantastic at backtracking and exploring different paths to find the right answer.</li>
                            </ol>
                            <div class="pro_vs_cons">
                                <h3>Advantages</h3>
                                <ol>
                                    <li>Talk to the Computer in Plain Language: The syntax of logical languages is so close to plain language that it feels like you're having a conversation with the computer. It's incredibly user-friendly! </li>
                                    <li>High-Level Power: Logical languages allow you to work on a high level of abstraction. You can express complex relationships and rules in a clear and concise way.</li>
                                    <li>Unlock the Power of Reasoning: These languages excel at solving complex logical problems, making them perfect for puzzles, expert systems, and more.</li>
                                    <li>Inference Engines at Your Service: Logical languages come with built-in inference engines that can deduce conclusions from the information you provide. Perfect for systems that need to make decisions!</li>
                                    <li>Knowledge Representation: They're unparalleled for representing and querying knowledge bases. This makes them superstars in AI applications, rule engines, and expert systems. </li>
                                </ol>         
                            
                                <h3>Disadvantages</h3>
                
                                <ol>
                                    <li>Efficiency Challenges: Sometimes, logical languages can be slower for certain tasks due to extensive backtracking and searching for solutions. But don't worry; efficiency is improving!</li>
                                    <li>Complexity Quest: Writing efficient and complex logical programs can be a bit challenging. You need to understand how the system performs inference and backtracking.</li>
                                    <li>Limited Application: While they're perfect for certain domains, logical languages might not be the best choice for every programming task.</li>
                                    <li>Mind-Bending: Learning to think in terms of logical rules and predicates can be a bit of a puzzle, especially if you're new to the paradigm.</li>
                                    <li>Expect the Unexpected: The non-deterministic nature of logical programming can lead to surprising results if not tamed by a skilled programmer.</li>
                                </ol>
            
                            </div>
            
                            <h4>Examples</h4>
                            <ul>
                                <li>Prolog</li>
                                <li>Datalog</li>
                                <li>Mercury</li>
                            </ul>
                    </section>
        
                </main>
        </div>
        </div>
    </body>
</html>